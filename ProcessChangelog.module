<?php

/**
 * Process Changelog
 *
 * This module keeps track of changes (edits, additions, removals etc.) on
 * pages of your site.
 *
 * For detailed information, installation instructions etc. see README.md.
 *
 * @copyright Copyright (c) 2013, Teppo Koivula
 *
 * ProcessWire 2.x 
 * Copyright (C) 2013 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */
 
class ProcessChangelog extends Process implements ConfigurableModule {
    
    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(
            'title' => __('Changelog'),
            'summary' => __('Keep track of changes (edits, removals, additions etc.)'),
            'href' => 'http://modules.processwire.com/modules/process-changelog/',
            'author' => 'Teppo Koivula',
            'version' => 108,
            'singular' => true,
            'autoload' => false,
            'installs' => 'ProcessChangelogHooks'
        ); 
    }
    
    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData() {
        return array(
            'row_limit' => 25,
            'row_label' => 'name',
            'date_format' => 'Y-m-d H:i:s'
        );
    }
    
    /**
     * Names of admin page and database table used by this module
     *
     */
    const PAGE_NAME = 'changelog';
    const TABLE_NAME = 'process_changelog';

    /**
     * Array of operations being logged
     *
     */
    protected $operations = array();

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     *
     */
    public function __construct() {
        // settings of ProcessChangelogHooks module define which operations get logged,
        // so we'll get that information from there in order to keep things consistent.
        if ($this->modules->isInstalled("ProcessChangelogHooks")) {
            $config = $this->modules->getModuleConfigData("ProcessChangelogHooks");
            if (isset($config['operations'])) {
                $this->operations = $config['operations'];
            } else {
                $defaults = $this->modules->get("ProcessChangelogHooks")->getDefaultData();
                $this->operations = $defaults['operations'];
            }
        }
        // default settings for current module
        foreach(self::getDefaultData() as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // merge default config settings (custom values overwrite defaults)
        $defaults = self::getDefaultData();
        $data = array_merge($defaults, $data);

        // date format used
        $field = $modules->get("InputfieldText");
        $field->name = "date_format";
        $field->label = __("Date Format");
        $field->notes = __("See the [PHP date](http://www.php.net/manual/en/function.date.php) function reference for more information on how to customize this format.");
        $field->value = ($data['date_format']) ? $data['date_format'] : $defaults['date_format'];
        $field->size = 70;
        $fields->add($field);

        // number of results visible at once
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_limit";
        $field->label = __("Row Limit");
        $field->description = __("Number of rows visible at once");
        $field->required = true;
        $field->addOptions(array(
            25 => '25', 
            50 => '50', 
            75 => '75', 
            100 => '100'
        ));
        $field->value = $data['row_limit'];
        $fields->add($field);

        // field to use as row label
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_label";
        $field->label = __("Row Label");
        $field->description = __("Which field should be used as row label?");
        $field->required = true;
        $field->addOptions(array(
                'name' => 'Page name',
                'url' => 'Page URL'
            ));
        $field->value = $data['row_label'];
        $fields->add($field);

        return $fields;
    }

    /**
     * Initialization function called before any execute functions
     *
     */
    public function init() {
        parent::init();
    }

    /**
     * Executed when a page with this Process assigned is accessed
      *
     * @return string
     */
    public function ___execute() {
        
        // setup admin data table
        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->setClass('changelog');
        $table->headerRow(array(
                __('User'),
                __('When'),
                __('What'),
                '', // placeholder
                __('More')
            ));

        // should date formatting occur?
        $defaults = self::getDefaultData();
        $date_format = ($this->date_format != $defaults['date_format']) ? $this->date_format : null;

        // build query
        $where = array();
        $allowed_keys = array(
            "id",
            "user_id",
            "username",
            "pages_id",
            "operation",
            "when",
            "date_from",
            "date_until"
        );
        $allowed_intervals = array(
            "1 DAY",
            "1 WEEK",
            "1 MONTH",
            "1 YEAR"
        );
        foreach ($this->input->get as $key => $value) {
            if (in_array($key, $allowed_keys) && $value != "") {
                $value = $this->db->real_escape_string($value);
                if ($key == "operation" && !in_array($value, $this->operations)) {
                    // only operations being currently logged can be used here
                    unset($this->input->get->$key);
                    continue;
                }
                if ($key == "data") {
                    $where[] = "$key LIKE '%$value%'";
                } elseif ($key == "when") {
                    if (in_array($value, $allowed_intervals)) {
                        $where['when'] = "DATE_SUB(CURDATE(), INTERVAL $value) <= timestamp";
                    }
                } elseif ($key == "date_from" || $key == "date_until") {
                    if (!isset($where['when'])) {
                        $value = date("Y-m-d", strtotime($value));
                        if ($key == "date_from") {
                            $operator = ">=";
                            $time = "00:00";
                        } else {
                            $operator = "<=";
                            $time = "23:59";
                        }
                        $where[$key] = "timestamp $operator '$value $time'";
                    }
                } else {
                    $operator = "=";
                    if (strpos($value, "!") === 0) {
                        $value = substr($value, 1);
                        $operator = "!=";
                    }
                    $where[] = "$key $operator '$value'";
                }
            }
        }

        // make sure that only operations being currently logged are visible,
        // even after selecting "all operations"
        if (!$this->input->get->operation) {
            $value = $this->db->real_escape_string(implode(",", $this->operations));
            $where[] = "operation IN('" . str_replace(",", "','", $value) . "')";
        }

        // if filters exist, put together where clause
        $where = $where ? " WHERE " . implode(" AND ", $where) : "";

        // variables required by pager
        $start = 0;
        $limit = $this->row_limit;
        $sql = "SELECT COUNT(*) FROM " . self::TABLE_NAME . " $joins $where";
        $total = reset($this->db->query($sql)->fetch_row());
        if ($total > $limit) {
            if ($this->input->get->page) $start = ($this->input->get->page-1)*$limit;
            if ($start > $total) $start = $total-$limit;
        }

        // if less than two matches were found, disable table sorting
        if ($total < 2) $table->setSortable(false);

        // fetch rows from database
        $sql = "SELECT " . self::TABLE_NAME . ".*
                FROM " . self::TABLE_NAME . " 
                $where 
                ORDER BY timestamp DESC, id DESC
                LIMIT $start, $limit";
        $result = $this->db->query($sql);

        while($row = $result->fetch_assoc()) {

            // empty container
            $data = array();
            
            // escape values (just a precaution really)
            foreach ($row as $key => $value) {
                if ($key != "data") $row[$key] = htmlentities($value);
            }

            // check if user still exists
            $user = $this->users->get($row['user_id']);
            if (!$user->id) $data[] = $row['username'] . " <em>(" . __("deleted") . ")</em>";
            else $data[$user->name] = $this->config->urls->admin."access/users/edit/?id=".$user->id;

            // timestamp (raw timestamp is hidden and only included to allow proper ordering with JavaScript)
            $date = ($date_format) ? date($date_format, strtotime($row['timestamp'])) : $row['timestamp'];
            $data[] = "<span>{$row['timestamp']}</span>$date";

            // translatable operations
            // __('added')
            // __('moved')
            // __('edited')
            // __('trashed')
            // __('renamed')
            // _x('deleted', 'operation')
            // __('restored')
            // __('published')
            // __('unpublished')

            // variables we're going to need later
            $target = "";
            $operation = $row['operation'];
            $page = $this->pages->get($row['pages_id']);
            $details = json_decode($row['data'], true);
            $key = $this->row_label == 'url' ? 'URL' : 'page name';
            
            // start putting together human-readable version of what happened
            switch ($operation) {
                case 'renamed':
                    $target .= $details["Previous $key"] 
                             . " <strong>" . __("as") . "</strong> " 
                             . $details["Current $key"];
                    break;
                case 'trashed':
                    $target .= $details["Previous $key"];
                    break;
                case 'restored':
                    $target .= $details["Current $key"];
                    break;
                default:
                    if (isset($details[($key == "URL" ? "Page URL" : ucfirst($key))])) {
                        $target .= $details[($key == "URL" ? "Page URL" : ucfirst($key))];
                    } elseif (isset($details["Current $key"])) {
                        $target .= $details["Current $key"];
                    }
            }

            if ($page->id) {
                // edit link
                $href = "{$this->config->urls->admin}page/edit/?id={$page->id}";
                $target .= " &nbsp; <a class='edit' href='$href'>" . __("edit page") . "</a></em>";
                // type (template)
                $type_icons = "";
                if ($page->template->flags & Template::flagSystem) {
                    $type_icons .= "<b class='icon system' title='" . __("System template") . "'></b>";
                }
                $type_label = $page->template->label ? $page->template->label : $page->template;
                $type = "<strong class='template'>$type_label$type_icons</strong>";
            } else {
                // page has been deleted
                $type = "<strong class='deleted'>" . __("deleted") . "</strong>";
            }

            // "deleted" is only phrase used in multiple contexts
            if ($operation != "deleted") $operation_i18n = __($operation);
            else $operation_i18n = _x($operation, 'operation');

            $data[] = "<strong>$operation_i18n</strong> $type $target";

            // link for removing individual row
            $data[] = "<a href='./delete/?id={$row['id']}' class='remove'>" . __("remove?") . "</a>";

            // more details about page in question
            $data[] = $details ? $this->renderDetails($operation, $details) : __("No data available.");

            $table->row($data);
            
        }

        // pager markup
        $pager = "";
        if ($total > $limit) {
            $pager_links = 20;
            $pager_page = (int) $start/$limit+1;
            $pager_pages = ceil($total/$limit);
            $pager = $this->renderPager($pager_links, $pager_page, $pager_pages);
        }

        // UI translations
        $translations = "<div id='translations'>";
        $translations .= "<span data-term='more'>" . __("more") . "</span>";
        $translations .= "<span data-term='less'>" . __("less") . "</span>";
        $translations .= "<span data-term='are_you_sure'>" . __("Are you sure?") . "</span>";
        $translations .= "<span data-term='remove_failed'>" . __("Sorry, remove failed") . "</span>";
        $translations .= "</div>";

        // Basic information about found rows
        $info = "<div id='info'><p>";
        $info .= sprintf(_n("One matching row found.", "%d matching rows found.", $total), $total);
        $info .= "</p></div>";

        // return admin data table markup, pager and translations
        return $this->renderFilters().$info.$table->render().$pager.$translations;

    }

    /**
     * Render markup for pager
     *
     * @param int $links Number of pager links visible at once
     * @param int $page Identifies currently active pager item
     * @param int $pages Number of total pager items available
     * @return string
     */
    private function renderPager($links, $page, $pages) {

        if ($pages < 2) return;

        // convert GET params to string
        $get = "";
        foreach ($this->input->get as $key => $value) {
            if ($key != "page" && $value != "") {
                $get .= "&".urlencode($key)."=".urlencode($value);
            }
        }

        // calculate start and end points
        $start = 1;
        $end = $pages;
        if ($end > $links) {
            $start = (int) $page-$links/2;
            if ($start < 1) $start=1;
            $end = $start+($links-1);
            if ($end > $pages) $end = $pages;
            if ($end-$page < (int) $links/2-1) { 
                $start -= ((int) $links/2)-($end-$page);
                if ($start < 1) $start=1;
            }
        }

        // generate markup
        $out = "<ul class='MarkupPagerNav MarkupPagerNavCustom'>";
        if ($start > 1) {
            $out .= "<li><a href='./?page=1$get'><span>1</span></a></li>";
            if ($start > 2) {
                $out .= "<li class='MarkupPagerNavSeparator'>&hellip;</li>";
            }
        }
        for ($i = $start; $i<=$pages; ++$i) {
            $here = ($page == $i) ? " class='MarkupPagerNavOn'" : "";
            $out .= "<li$here><a href='./?page=$i$get'><span>$i</span></a></li>";
            if ($pages > $links && $i == $end && $i < $pages) {
                if ($pages-$i > 1) {
                    $out .= "<li class='MarkupPagerNavSeparator'>&hellip;</li>";
                }
                $i = $pages-1;
                if ($i < $end) $i = $end+1;
            }
        }
        $out .= "</ul>";
        
        return $out;

    }

    /**
     * Render human readable view of row details
     *
     * @param string $operation
     * @param array $details
     * @return string
     */
    private function renderDetails($operation = null, $details = array()) {

        // action details are required
        if (!$details) return false;

        // init vars
        $markup = "";
        $class = ($operation) ? " icon-$operation" : "";

        // translatable phrases
        // __('Previous page name')
        // __('Current page name')
        // __('Page name')
        // __('Page title')
        // __('Parent page')
        // __('Previous parent page')
        // __('Page URL')
        // __('Previous URL')
        // __('Current URL')
        // __('Fields edited')

        foreach ($details as $key => $value) {
            // escape key and value
            $key = htmlentities($key);
            $value = htmlentities($value);
            // generate markup
            $markup .= "<tr><th>" . __($key) . "</th><td>$value</td></tr>";
        }
        
        return "<table class='details$class'>$markup</table>";

    }

    /**
     * Executed when requesting removal of an individual row
     *
     * @return boolean
     */
    public function ___executeDelete() {

        if ((int) $this->input->get->id != $this->input->get->id) return false;

        $id = (int) $this->input->get->id;
        $sql = "DELETE FROM " . self::TABLE_NAME . " WHERE id = $id LIMIT 1";
        $this->db->query($sql);

        return true;

    }

    /**
     * Render markup for result filter UI
     *
     * @return string 
     */
    private function renderFilters() {

        $markup = "";

        // Action types
        $options = array_merge(array(__("All operations")), $this->operations);
        $markup .= $this->renderSelect('operation', $options, true);

        // Username
        $options = array();
        $operation = $this->db->real_escape_string($this->input->get->operation);
        $where = ($operation) ? " WHERE operation = '$operation'" : "";
        $sql = "SELECT DISTINCT username 
                FROM " . self::TABLE_NAME . "
                $where 
                ORDER BY username DESC";
        $result = $this->db->query($sql);
        if (!$result->num_rows || $result->num_rows > 1) {
            $options[] = __("by any user");
        }
        while($row = $result->fetch_assoc()) {
            $key = sprintf(__("by %s"), $row['username']); // by %s // %s will be replaced run-time by username
            $options[$key] = $row['username'];
        }
        $markup .= $this->renderSelect('username', $options);

        // Date options
        $options = array(
            __("whenever"),
            __("within a day") => '1 DAY',
            __("within a week") => '1 WEEK',
            __("within a month") => '1 MONTH',
            __("within a year") => '1 YEAR',
            __("between")
        );
        $markup .= $this->renderSelect('when', $options);

        // Date range
        $disabled_title = __("Not relevant in this context");
        $date_from = ($this->input->get->date_from) ? date('d.m.Y', strtotime($this->input->get->date_from)) : '';
        $date_until = ($this->input->get->date_until) ? date('d.m.Y', strtotime($this->input->get->date_until)) : '';
        $markup .= "<input type='text'"
                 . " value='$date_from'"
                 . " size='10'"
                 . " data-maxdate='+0D'"
                 . " data-dateformat='dd.mm.yy'"
                 . " name='date_from'"
                 . " data-disabled-title='$disabled_title'"
                 . " class='changelog-datepicker'"
                 . " />"
                 . " .. "
                 . "<input type='text'"
                 . " value='$date_until'"
                 . " size='10'"
                 . " data-maxdate='+0D'"
                 . " data-dateformat='dd.mm.yy'"
                 . " name='date_until'"
                 . " class='changelog-datepicker'"
                 . " />";

        return "<form id='filters'>$markup</form>";
        
    }

    /**
     * Render markup for select element
     *
     * @param string name
     * @param array $options
     * @param boolean $translate
     * @return string
     */
    private function renderSelect($name, array $options, $translate) {
        
        if (!$name) return;

        $markup = "";

        foreach ($options as $key => $option) {
            $value = $key ? $option : '';
            $text = !is_numeric($key) ? $key : $option;
            if ($translate) {
                // phrase "deleted" is used in multiple contexts
                if ($text == "deleted") $text = _x($text, $name);
                else $text = __($text);
            }
            $selected = ($this->input->get->$name == $value) ? ' selected="selected"' : '';
            $markup .= "<option$selected value='$value'>$text</option>";
        }

        return "<select name='$name'>$markup</select>";

    }

    /**
     * Called only when this module is installed
     *
     * Creates new page with this Process module assigned and new database
     * table for storing data.
     *
     */
    public function ___install() {

        // create database table this module requires
        $sql = "
        CREATE TABLE " . self::TABLE_NAME . " (
            id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
            user_id INT(10) UNSIGNED NOT NULL DEFAULT 0,
            username VARCHAR(128) DEFAULT NULL,
            pages_id INT(10) UNSIGNED NOT NULL DEFAULT 0,
            operation VARCHAR(128) NOT NULL,
            data TEXT DEFAULT NULL,
            timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        ) ENGINE = MYISAM;
        ";
        $this->db->query($sql);

        // tell the user that we've created new database table
        $this->message("Created Table: " . self::TABLE_NAME); 

        // create a page for this module
        $page = new Page();
        $page->template = 'admin';
        $page->name = self::PAGE_NAME; 
        $page->process = $this; 

        // insert page under setup at admin
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');

        // make page title match module title
        $info = self::getModuleInfo();
        $page->title = $info['title'];

        // save the page
        $page->save();

        // tell user that we've created a new page
        $this->message("Created Page: {$page->path}"); 

    }

    /**
     * Called only when this module is uninstalled
     *
     * Removes page associated with this Process module and also drops related table.
     *
     */
    public function ___uninstall() {

        // find the page we installed, locating it by the process field (which has the module ID)
        // it would probably be sufficient just to locate by name, but this is just to be extra sure.
        $moduleID = $this->modules->getModuleID($this); 
        $page = $this->pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME); 

        if($page->id) {
            // if we found the page, let the user know and delete it
            $this->message("Deleting Page: {$page->path}"); 
            $page->delete();
        }

        // if database table exists, drop it
        $this->message("Deleting Table: " . self::TABLE_NAME);
        $this->db->query("DROP TABLE IF EXISTS " . self::TABLE_NAME);

    }
    
}
